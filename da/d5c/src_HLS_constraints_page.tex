The distinction between constraints and objectives is straightforward\+: a {\bfseries constraint} is a design target that must be met in order for the design to be considered successful. For example, a chip may be required to run at a specific frequency in order to interface with other components in a system. In contrast, an {\bfseries objective} is a design target where more (or less) is better. For example, yield is generally an objective, which is maximized to lower manufacturing cost. Constraints in architectural synthesis can be classified into two major groups\+: {\itshape interface constraints} and {\itshape implementation constraints}.

Interface constraints are additional specifications to ensure that the circuit can be embedded in a given environment. They relate to the format and timing of the I/O data transfers. The data format is often specified by the interface of the model. The timing separation of I/O operations can be specified by timing constraints that can ensure that a synchronous I/O operation follows/precedes another one by a defined number of cycles in a given interval. Timing constraints can also specify data rates for pipelined systems.

Implementation constraints reflect the desire of the designer to achieve a structure with some properties. Examples are area constraints and performance constraints, e.\+g., cycle-\/time and/or latency bounds.

A different kind of implementation constraint is a {\itshape resource binding constraint} (see \hyperlink{src_HLS_binding_constraints_page}{Binding constraints}). In this case, a particular operation is required to be implemented by a given resource. These constraints are motivated by the designer\textquotesingle{}s previous knowledge, or intuition, that one particular choice is the best and that other choices do not need investigation. Architectural synthesis with resource binding constraints is often referred to as synthesis from partial structure. Design systems that support such a feature allow a designer to specify a circuit in a wide spectrum of ways, ranging from a full behavioral model to a structural one. This modeling capability may be useful to leverage previously designed components.

Design constraints are formulated as equalities or inequalities. For example, design constraints can be\+:
\begin{DoxyItemize}
\item $Area(x) \leq Area_{max}$; where $Area(x)$ is area occupied by the design solution $x$ and $Area_{max}$ is the maximum allowed for total occupied area;
\item $Time(x) \leq Time_{max}$; where $Time(x)$ is latency of the solution $x$ and $Time_{max}$ is maximum latency allowed to consider the solution admissible.
\end{DoxyItemize}

A solution that doesn\textquotesingle{}t meet all design constraints is not considered feasible and will have to be discarded.\hypertarget{src_HLS_constraints_page_sec_constraints_bambu}{}\section{Design constraints in the Bambu tool}\label{src_HLS_constraints_page_sec_constraints_bambu}
The {\itshape design constraints} represent the constraints imposed by the designer (or by the architecture of the target devices) to the final design. For instance, for F\+P\+GA designs, a constraint that can be imposed is the maximum number of area units that can be used by the final R\+TL design, e.\+g. maximum number of Configurable Logic Blocks (C\+L\+Bs) to be used. Further constraints can be the maximum number of instances that can be allocated for a resource type (e.\+g. the maximum number of A\+L\+Us or registers). 