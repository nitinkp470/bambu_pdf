\hypertarget{src_HLS_scheduling_general_scheduling_definition}{}\section{Scheduling problem definition}\label{src_HLS_scheduling_general_scheduling_definition}
The scheduling problem is the problem of determining the order in which the operations in the behavioral description will be executed. Within a control step, a separated functional unit is required to execute each operation assigned to that step. Thus, the total number of functional units required in a control step directly corresponds to the number of operations scheduled into it. If more operations are scheduled into each control step, more functional units are necessary, which results in fewer control steps for the design implementation. On the other hand, if fewer operations are scheduled into each control step, fewer functional units are sufficient, but more control steps are needed. Thus, scheduling determines the tradeoff between design cost and performance. A {\itshape scheduling function} $\theta : V_0 \rightarrow \Pi(N^n)$ assigns to each D\+FG node $v \in V_0$ a sequence of cycle steps in which the node is executed. If these cycle steps are continuous, this will be called the {\itshape execution interval} of the operation {\itshape v}. A schedule will be called a {\itshape simple} schedule if all operations have an execution interval of length one. In this work, only execution in continuous cycle steps will be considered.\hypertarget{src_HLS_scheduling_general_mutual_exclusion}{}\section{Mutual exclusion}\label{src_HLS_scheduling_general_mutual_exclusion}
{\bfseries Mutual exclusion}\+: two operations will be called mutually exclusive if they are executed under mutually exclusive conditions. A {\itshape mutual exclusive function} $m : V_0 \rightarrow \Pi(N)$ is defined such that\+: $m(v_i) \wedge m(v_j) = 0$ when operations $v_i$ and operation $v_j$ are executed under mutually exclusive conditions.\hypertarget{src_HLS_scheduling_general_scheduling_approach}{}\section{Scheduling common approaches}\label{src_HLS_scheduling_general_scheduling_approach}
There are two classes of scheduling problems\+: {\itshape time-\/constrained} scheduling and {\itshape resource-\/constrained} scheduling. Time-\/constrained scheduling minimizes the hardware cost when all operations are to be scheduled into a fixed number of control steps. Resource-\/constrained scheduling, instead, minimizes the number of control steps needed for executing all operations given a fixed amount of hardware.

The simplest constructive approach is the as soon as possible (A\+S\+AP) scheduling. First, operations are sorted into a list according to their topological order. Then, operations are taken from the list one at a time and placed into the earliest possible control step. The other simple approach is the as late as possible (A\+L\+AP) scheduling. The A\+L\+AP value for an operation defines the latest control step into which an operation can possibly be scheduled. In this approach, given a time constraint in terms of the number of control steps, the algorithm determines the latest possible control step in which an operation must begin its execution. The {\bfseries critical paths} within the flow graph can be found by taking the intersection of the A\+S\+AP and A\+L\+AP schedules such that the operations that appear in the same control steps in both schedules are on the critical paths.\hypertarget{src_HLS_scheduling_general_scheduling_algorithm}{}\section{Implemented algorithms for scheduling}\label{src_HLS_scheduling_general_scheduling_algorithm}
There are different algorithms implemented to solve the scheduling problem\+:
\begin{DoxyItemize}
\item src\+\_\+\+H\+L\+S\+\_\+scheduling\+\_\+list\+\_\+based\+\_\+page solve scheduling using list based algorithm.
\item src\+\_\+\+H\+L\+S\+\_\+scheduling\+\_\+ilp\+\_\+scheduling\+\_\+page solve scheduling exploting an I\+LP formulation of the scheduling problem.
\item src\+\_\+\+H\+L\+S\+\_\+scheduling\+\_\+ilp\+\_\+scheduling\+\_\+new\+\_\+page solve scheduling exploting a new I\+LP formulation of the scheduling problem.
\item src\+\_\+\+H\+L\+S\+\_\+scheduling\+\_\+silp\+\_\+scheduling\+\_\+page solve scheduling exploting a S\+I\+LP formulation of the scheduling problem.
\item src\+\_\+\+H\+L\+S\+\_\+scheduling\+\_\+force\+\_\+directed\+\_\+page solve scheduling using a new formulation of force directed algorithm
\item src\+\_\+\+H\+L\+S\+\_\+path\+\_\+based\+\_\+page solve scheduling using a path based approach.
\end{DoxyItemize}

An operation can be potentially executed if all its inputs have been already computed. Then the operation is selected to be executed if there is a free resource that is able to execute the type of the operation. If the operation has a partial binding (see \hyperlink{src_HLS_binding_constraints_page}{Binding constraints}) to a specific functional unit instance, the algorithm will have simply to check if the specific instance which the operation is bounded is free (not a generic one). If it is free, the operation can be assigned to its functional unit instance and scheduled in the current control step; if the resource is busy, the operation will be kept in the list and the next one is tested. When a partial binding has not been specified before for some operations, the algorithm performs the usual methodology to associate them to free resources. 